#!/usr/bin/env perl

use strict;
use warnings;

BEGIN {
  if (-e './setlib.cfg') {
    unshift @INC, '.';
  } elsif (-e '../bin/setlib.cfg') {
    unshift @INC, '../bin';
  }
  require 'setlib.cfg';
}

use Foswiki ();
use Foswiki::UnifiedAuth;
use DB_File;
use DB_File::Lock;
use Foswiki::Contrib::LdapContrib::DBFileLockConvert;

Foswiki->new('admin');

my $uauth = Foswiki::UnifiedAuth->new();

my $session = $Foswiki::Plugins::SESSION;
my $workArea = $session->{store}->getWorkArea('LdapContrib');
my $cacheFile = $workArea . '/cache.db';
die "Cache does not exist: $cacheFile" unless -e $cacheFile;

my $provider = $ARGV[0];
if(!$provider){
    print "Usage: perl synchronize_ldap_to_uac <providerName> [nodry]\n";
    print "\tThe first parameter is the name of the ldap provider\n";
    print "\tThe second parameter needs to be set to 'nodry' if you want the script to save changes to the database.\n\n";

    print "This script imports the ldap mappings 'login name => wiki name' that were present in LdapContrib installations.\n";
    print "It only needs to be executed if you are migrating from an existing LdapContrib installation to UnifiedAuth.\n\n";

    print "Before you run this script make sure that UnifiedAuth has an ldap provider configured that corresponds to the old LdapContrib configuration.\n";
    print "Also make sure that all users have been imported by refreshing the provider.\n";
    print "By default it will perform a dry run. If you want to save the changes call the script with 'nodry' as second parameter.\n";
    exit;
}

#Perform a dry run per default
my $isDry =  !($ARGV[1] && ($ARGV[1] eq 'nodry'));

my %db_hash;
tie %db_hash, $Foswiki::UNICODE ? 'Foswiki::Contrib::LdapContrib::DBFileLockConvert' : 'DB_File::Lock', $cacheFile, O_RDONLY, 0664, $DB_HASH, 'read' or die "Error tieing cache file $cacheFile: $!";

my $actions = [];
foreach my $login (split(',', $db_hash{LOGINNAMES})) {
    my $wikiname = $db_hash{"U2W::$login"};
    unless ($wikiname) {
        print "cache corrupt for $login: no WikiName\n";
        next;
    }

    push @$actions, {login_name => $login, wiki_name => $wikiname};
}

if($isDry){
    print "Performing a dry run: Nothing is saved!\n";
    print "Run the script with 'nodry' as second argument to save changes.\n";
}
my $report = $uauth->update_wikiname($actions, $provider, $isDry);
if($report->{error}) {
    print "Error: $report->{error}\n";
} else {
    print "Successfully processed $report->{successes} records.\nUpdated: $report->{updated}\n";
    if($report->{errors}) {
        print "ATTENTION! There were $report->{errors} errors.\n";
        use Data::Dumper;
        $Data::Dumper::Terse = 1;
        foreach my $e (@{$report->{report}}) {
            print Dumper($e) if $e->{error};
        }
    }
    if($report->{clashes} && scalar @{$report->{clashes}}) {
        print "ATTENTION! There were name-clashes with these cuids: ".join(', ', @{$report->{clashes}})."\n";
    }
}

untie(%db_hash);
